"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[330],{3905:function(e,r,n){n.r(r),n.d(r,{MDXContext:function(){return c},MDXProvider:function(){return m},mdx:function(){return h},useMDXComponents:function(){return p},withMDXComponents:function(){return d}});var t=n(67294);function a(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function o(){return(o=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var n=arguments[r];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e}).apply(this,arguments)}function i(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function s(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?i(Object(n),!0).forEach((function(r){a(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function l(e,r){if(null==e)return{};var n,t,a=function(e,r){if(null==e)return{};var n,t,a={},o=Object.keys(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||(a[n]=e[n]);return a}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=t.createContext({}),d=function(e){return function(r){var n=p(r.components);return t.createElement(e,o({},r,{components:n}))}},p=function(e){var r=t.useContext(c),n=r;return e&&(n="function"==typeof e?e(r):s(s({},r),e)),n},m=function(e){var r=p(e.components);return t.createElement(c.Provider,{value:r},e.children)},u={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},f=t.forwardRef((function(e,r){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=a,f=d["".concat(i,".").concat(m)]||d[m]||u[m]||o;return n?t.createElement(f,s(s({ref:r},c),{},{components:n})):t.createElement(f,s({ref:r},c))}));function h(e,r){var n=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=f;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return t.createElement.apply(null,i)}return t.createElement.apply(null,n)}f.displayName="MDXCreateElement"},64288:function(e,r,n){n.r(r),n.d(r,{contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var t=n(83117),a=n(80102),o=(n(67294),n(3905)),i=["components"],s={sidebar_position:7,id:"calibration",title:"Using Calibration Sensor Data"},l="Using Calibration Sensor Data",c={unversionedId:"howto/calibration",id:"howto/calibration",isDocsHomePage:!1,title:"Using Calibration Sensor Data",description:"Introduction",source:"@site/docs/howto/calibration.md",sourceDirName:"howto",slug:"/howto/calibration",permalink:"/Aria_data_tools/docs/howto/calibration",editUrl:"https://github.com/facebookresearch/aria_data_tools/docs/howto/calibration.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,id:"calibration",title:"Using Calibration Sensor Data"},sidebar:"tutorialSidebar",previous:{title:"Visualize Sequences and Pre-Computed Camera Trajectory",permalink:"/Aria_data_tools/docs/howto/visualizing"},next:{title:"Aria Pilot Dataset Overview",permalink:"/Aria_data_tools/docs/pilotdata/pilotdata-index"}},d=[{value:"Introduction",id:"introduction",children:[]},{value:"Project Aria device calibration",id:"project-aria-device-calibration",children:[]},{value:"Sensors",id:"sensors",children:[]},{value:"Calibration",id:"calibration",children:[{value:"Extrinsics",id:"extrinsics",children:[]},{value:"Intrinsics",id:"intrinsics",children:[]}]}],p={toc:d};function m(e){var r=e.components,n=(0,a.Z)(e,i);return(0,o.mdx)("wrapper",(0,t.Z)({},p,n,{components:r,mdxType:"MDXLayout"}),(0,o.mdx)("h1",{id:"using-calibration-sensor-data"},"Using Calibration Sensor Data"),(0,o.mdx)("h2",{id:"introduction"},"Introduction"),(0,o.mdx)("p",null,"This page covers:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"General Project Aria device calibration principles"),(0,o.mdx)("li",{parentName:"ul"},"Python3 scripts for extrinsics and intrinsics")),(0,o.mdx)("h2",{id:"project-aria-device-calibration"},"Project Aria device calibration"),(0,o.mdx)("p",null,"Calibration data can be used to determine the 6DoF transformation between any pair of Project Aria device's sensors."),(0,o.mdx)("p",null,"Project Aria devices contain multiple types of sensors that are all calibrated when each device is manufactured. The calibration process derives intrinsic and extrinsic parameters (relative poses between sensors). This information is stored on every device and inserted into every ",(0,o.mdx)("a",{parentName:"p",href:"/Aria_data_tools/docs/aria-vrs"},"VRS")," data file it records."),(0,o.mdx)("p",null,"In Python3, you can fetch this information from VRS and parse it into a data structure using the following code snippet:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},">>> import pyark\n>>> reader = pyark.datatools.sensors.RecordFileReader()\n>>> reader.openFile('./data/aria_unit_test_sequence_calib.vrs')\n[ProgressLogger][INFO]: 26881.515: Opening diskfile file...0\n>>> deviceModel = pyark.datatools.sensors.DeviceModel.fromJson(pyark.datatools.sensors.getCalibrationFromVrsFile(reader))\n")),(0,o.mdx)("h2",{id:"sensors"},"Sensors"),(0,o.mdx)("p",null,"Go to ",(0,o.mdx)("a",{parentName:"p",href:"/Aria_data_tools/docs/sensors-measurements"},"Sensors and Measurements")," for information about Project Aria device sensors and how they are described in the tooling."),(0,o.mdx)("h2",{id:"calibration"},"Calibration"),(0,o.mdx)("p",null,"In computer vision, camera calibration is managed by two sets of parameters:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("strong",{parentName:"li"},"Intrinsics"),": Parameters defining how 3D points project to the image plane (focal, principal point, distortions coefficients, and so on). Intrinsics parameters allow you to ",(0,o.mdx)("em",{parentName:"li"},"project")," 3D points in 2D and ",(0,o.mdx)("em",{parentName:"li"},"unproject")," 2D feature observations to 3D rays (bearing vectors)."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("strong",{parentName:"li"},"Extrinsics"),": Parameters defining where the camera is in space (Rotation|Translation). Extrinsics allow you to move world points to the camera coordinate system.")),(0,o.mdx)("h3",{id:"extrinsics"},"Extrinsics"),(0,o.mdx)("p",null,"Extrinsic parameters are represented as a SE(3) matrix, that contains a rotation part (SO(3)) as a unit quaternion and a translation part as an R3 coordinate. To manipulate transformations such as relative pose between sensors, or re-projecting a 3D point from one sensor to another we use the ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/strasdat/Sophus"},"Sophus library"),"."),(0,o.mdx)("p",null,"In the code and the documentation throughout this project, we use the following notation:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"p_sensor")," represents an R3 point in the local coordinate system of ",(0,o.mdx)("inlineCode",{parentName:"li"},"sensor"),". e.g. ",(0,o.mdx)("inlineCode",{parentName:"li"},"p_slamLeft"),"."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"T_sensor1_sensor2")," represents a relative SE(3) transformation from ",(0,o.mdx)("inlineCode",{parentName:"li"},"sensor2")," frame to ",(0,o.mdx)("inlineCode",{parentName:"li"},"sensor1")," frame. An easy mnemonic is the chaining principle: ",(0,o.mdx)("inlineCode",{parentName:"li"},"T_sensor1_sensor2 * T_sensor2_sensor3 * p_sensor3 = p_sensor1"))),(0,o.mdx)("p",null,"You can transform a 3D point from one sensor to the another one using the ",(0,o.mdx)("inlineCode",{parentName:"p"},"transform()")," operator:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},">>> import numpy as np\n>>> p_slamLeft = np.array([3.0, 2.0, 1.0])\n>>> p_imuRight = deviceModel.transform(p_slamLeft, 'camera-slam-left', 'imu-right')\n>>> p_imuRight\narray([ 3.33343274, -1.41484796,  1.20512771])\n>>> deviceModel.transform(p_imuRight, 'imu-right', 'camera-slam-left')\narray([3., 2., 1.]) # as you see we retrieve the initial 3D point\n")),(0,o.mdx)("h3",{id:"intrinsics"},"Intrinsics"),(0,o.mdx)("p",null,"Cameras can be configured to have a function that maps a 3D point in its local coordinate frame to the image pixel space. The parameters of this projection function are called the intrinsic parameter of a camera. All cameras on Project Aria devices are fisheye cameras. This means they are modeled by a spherical projection followed by additional distortion correction (rather than being modeled by a pinhole projection plus distortion)."),(0,o.mdx)("p",null,"For Project Aria devices, we use:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"https://ieeexplore.ieee.org/document/1642666"},"Kannala-Brandt model")," for eye tracking cameras"),(0,o.mdx)("li",{parentName:"ul"},"FisheyeRadTanThinPrism model for SLAM and RGB cameras")),(0,o.mdx)("p",null,"You can perform the projection and un-projection operations using the following Python3 script:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},">>> p_slamLeft = np.array([3.0, 2.0, 1.0])\n>>> uv_slamLeft = deviceModel.getCameraCalib('camera-slam-left').projectionModel.project(p_slamLeft)\n>>> uv_slamLeft\narray([583.48105528, 411.98136675])\n>>> deviceModel.getCameraCalib('camera-slam-left').projectionModel.unproject(uv_slamLeft)\narray([3., 2., 1.]) #return the corresponding bearing_vector (ray)\n")),(0,o.mdx)("p",null,"The IMU sensors use a linear rectification model for both accelerometers and gyroscopes to compensate the measurement for factory-estimated systematic errors. The model includes a 3x3 rectification matrix A (correcting scale and non-orthogonality) and a 3x1 bias vector ",(0,o.mdx)("inlineCode",{parentName:"p"},"b"),"."),(0,o.mdx)("p",null,"To apply the rectification, use the Python3 scripts:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},">>> p_imuLeft = np.array([3.0, 2.0, 1.0])\n>>> deviceModel.getImuCalib('imu-left').accel.compensateForSystematicErrorFromMeasurement(p_imuLeft)\narray([2.93735023, 2.02130446, 0.87514154])`\n")),(0,o.mdx)("p",null,"This rectification process applies the formula:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"p_compensated = A.inv() * (p_raw - b)\n")),(0,o.mdx)("p",null,"When applied to accelerometer data, ",(0,o.mdx)("inlineCode",{parentName:"p"},"p_raw")," represents acceleration.  When applied to gyroscope data ",(0,o.mdx)("inlineCode",{parentName:"p"},"p_raw"),"  represents angular velocity."))}m.isMDXComponent=!0}}]);